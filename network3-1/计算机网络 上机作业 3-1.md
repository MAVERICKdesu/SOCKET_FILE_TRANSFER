# 计算机网络 上机作业 3-1

### 协议设计 

###### UDP数据包的结构

![image-20201207192520348](C:\Users\71465\AppData\Roaming\Typora\typora-user-images\image-20201207192520348.png)

- 从上到下，数据包的组成为：
  - 8位标志位
  - 数据包序号
  - 有效数据长度
  - 数据正文
  - 校验和
- 在本次实验中，用到了7个标志位，分别为：
  - SK1 SK2 SK3 分别代表第1，2，3次握手，也分别代表第1，2，3次挥手
  - ACK 表示接受到了正确的数据包
  - FIN 表示挥手数据包
  - SEND 表示发送数据
  - AGAIN 表示上一个数据包有误，请求重传
- 受到位数影响，数据包的序号需要对256进行取模，因此接受方接受到的数据包序号的范围为0~255
- 因为采用了停传方法来进行可靠传输，在没有接收到ACK数据包时Client是不会继续发送数据包的。因此发送AGAIN数据包时不需要指定数据包序号
- 数据包的二进制位数一定是8的整数倍数，如果数据正文不是8的整数倍数，则用0不齐。因为数据包中包含了真实的数据长度，可以还原原数据
- 校验和采用了checksum算法，即除了最后8位，将每8位进行异或操作，结果取反作为校验和

------

###### 三次握手和挥手

类似于TCP的握手协议。SK1 SK2 SK3三个标志位分别代表第1，2，3次握手

- 发送端发送SK1数据包
- 接收端接受SK1数据包，检查无误后发送SK2数据包
- 发送端接受SK2数据包，检查无误后发送SK3数据包，同时可以开始发送数据包
- 接收端接受SK3数据包
- 挥手同理

------

###### 文件打包和可靠传输

将要发送的文件以二进制读取，存储在char数组中。**split_file**函数负责将文件按照**PACKSIZE**的大小分成若干份，如果最后一份不足**PACKSIZE**则用0补齐。将数据存储在指针数组中，完成将文件分块。

发送文件时，需要将发送数据的第1，2，3位按照协议要求进行填写，然后将该序号对应的文件数据赋值给第4~**PACKSIZE**+3位，最后计算校验和并赋值给**PACKSIZE**+4位。

每次接收方接受到数据包后，必须发送一个ACK数据包，打包方式同上文，由此来确保收到了正确的数据。发送方也会等待接受这个ACK数据包，仅当接受到后才会发送下一个文件数据包。

------

###### 差错校验/超时重传机制

有两种情况需要启动重传机制

- 差错校验错误，即校验和错误
- 超过一定时间没有收到对方的数据包

对于第一种情况，需要发送AGAIN数据包让对方重新发送一次数据包。对于情况二，发送方如果没收到接收方的ACK数据，则需要重传

超时的检验方法是，将**recvfrom**函数改为非阻塞状态，并且在开启一个计时器线程，每Sleep(1)就对全局变量Time加一。当需要接受文件时，如果在RTO时间内函数的返回时都为-1则说明超时，需要进行重传。

如果在握手/挥手过程中出错，直接退出程序，需要重新开始整个流程。

------

###### 功能

发送任意文件，经过测试可以正确发送大图片，可以正常打开启用